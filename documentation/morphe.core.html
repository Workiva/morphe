<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>morphe.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Morphe</span> <span class="project-version">1.0.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="morphe.core.html"><div class="inner"><span>morphe.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="morphe.core.html#var-*warn-on-noop*"><div class="inner"><span>*warn-on-noop*</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-alter-bodies"><div class="inner"><span>alter-bodies</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-alter-bodies*"><div class="inner"><span>alter-bodies*</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-alter-form"><div class="inner"><span>alter-form</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-apply-aspect"><div class="inner"><span>apply-aspect</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-defn"><div class="inner"><span>defn</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-fn-form-.3Edefn"><div class="inner"><span>fn-form-&gt;defn</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-parse-defn"><div class="inner"><span>parse-defn</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-prefix-bodies"><div class="inner"><span>prefix-bodies</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-prefix-bodies*"><div class="inner"><span>prefix-bodies*</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-prefix-form"><div class="inner"><span>prefix-form</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">morphe.core</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-*warn-on-noop*"><h3>*warn-on-noop*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-alter-bodies"><h3>alter-bodies</h3><h4 class="type">macro</h4><div class="usage"><code>(alter-bodies fn-form expression)</code></div><div class="doc"><pre class="plaintext">Allows specification of code that should wrap each body of the `defn`
form. Provides:
  * &amp;params - The paramaters corresponding to this arity.
  * &amp;body - The collection of expressions in the body of this arity.
  * &amp;ns - The namespace in which this fn is being interned
  * &amp;name - The symbol used to name this defn.
  * &amp;meta - The metadata attached to the fn name.
  * &amp;env-keys - The keys of the &amp;env map known to the `defn` macro.
NOTA BENE: &amp;body is an *ordered collection* of valid expressions.
Example:
(alter-bodies fn-form
              `(binding [*scope* ~[(ns-name &amp;ns) &amp;name &amp;params]]
                 ~@&amp;body))</pre></div></div><div class="public anchor" id="var-alter-bodies*"><h3>alter-bodies*</h3><div class="usage"><code>(alter-bodies* fn-form f)</code></div><div class="doc"><pre class="plaintext">Takes a fn-form and a function of args [params body] and replaces each body
in the fn-form with the result of applying the function to the params and
the body! body should be assumed to be a collection of valid expressions.</pre></div></div><div class="public anchor" id="var-alter-form"><h3>alter-form</h3><h4 class="type">macro</h4><div class="usage"><code>(alter-form fn-form expression)</code></div><div class="doc"><pre class="plaintext">Allows specification of code that would wrap the entire `defn` form.
Useful mainly for providing a lexical scope (e.g., evaluating the `defn`
within the body of a `let`). Provides:
  * &amp;ns - The namespace in which this fn is being interned
  * &amp;name - The symbol used to name this defn.
  * &amp;meta - The metadata attached to the fn name.
  * &amp;env-keys - The keys of the &amp;env map known to the `defn` macro.
  * &amp;form - A placeholder for the actual form -- not the form itself.
NOTA BENE: &amp;form should always be assumed to represent a *single* expression.
Example: (alter-form fn-form `(binding [*my-var* 3 ~&amp;form)))</pre></div></div><div class="public anchor" id="var-apply-aspect"><h3>apply-aspect</h3><div class="usage"><code>(apply-aspect fn-form aspect)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-defn"><h3>defn</h3><h4 class="type">macro</h4><div class="usage"><code>(defn name doc-string? attr-map? [params*] prepost-map? body)</code><code>(defn name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?)</code></div><div class="doc"><pre class="plaintext">Should behave exactly like clojure.core/defn, except:
You can tag the fn name with aspects:
`^{:morphe.core/aspects [aspects ...]}`
The aspects must be functions of one argument that know how to manipulate a
morphe.core/FnForm record.

In implementation, it basically uses the guts of clojure.core/defn to parse
the definition, representing the parsed form with a FnForm record,
which then gets operated on by composable modification fns (aspects).

The FnForm record has the following fields:
  :env - the `&amp;env` var inside the `defn` call.
  :wrapper - A single expression not equal to, but representing any code that
             should wrap the `defn` call.
  :namespace - The namespace in which the fn is being interned.
  :fn-name - The symbolic name of the function being defined.
  :metadata - The metadata that was attached to the fn-name.
  :arglists - A sequence of arglists, one for each arity.
  :bodies - A sequence of arity bodies, where each body is a collection of expressions.</pre></div></div><div class="public anchor" id="var-fn-form-.3Edefn"><h3>fn-form-&gt;defn</h3><div class="usage"><code>(fn-form-&gt;defn fn-form)</code></div><div class="doc"><pre class="plaintext">Finally turns the FnForm record back into a complete code body.
</pre></div></div><div class="public anchor" id="var-parse-defn"><h3>parse-defn</h3><div class="usage"><code>(parse-defn name &amp; fdecl)</code></div><div class="doc"><pre class="plaintext">This duplicates Clojure.core's `defn`, but instead of constructing the function
definition, this returns a FnForm record containing the result of parsing the
defn.</pre></div></div><div class="public anchor" id="var-prefix-bodies"><h3>prefix-bodies</h3><h4 class="type">macro</h4><div class="usage"><code>(prefix-bodies fn-form expression)</code></div><div class="doc"><pre class="plaintext">Allows the specification of an expression that will be added to the beginning
of each fn arity (presumably for side-effects). Provides:
  * &amp;params - The paramaters corresponding to this arity.
  * &amp;ns - The namespace in which this fn is being interned
  * &amp;name - The symbol used to name this defn.
  * &amp;meta - The metadata attached to the fn name.
  * &amp;env-keys - The keys of the &amp;env map known to the `defn` macro.
Example: (prefix-bodies fn-form `(assert (even? 4) "Math still works."))</pre></div></div><div class="public anchor" id="var-prefix-bodies*"><h3>prefix-bodies*</h3><div class="usage"><code>(prefix-bodies* fn-form f)</code></div><div class="doc"><pre class="plaintext">Takes a fn-form and a function of args [params] and prefixes each body
in the fn-form with the result of applying the function to the params!</pre></div></div><div class="public anchor" id="var-prefix-form"><h3>prefix-form</h3><h4 class="type">macro</h4><div class="usage"><code>(prefix-form fn-form expression)</code></div><div class="doc"><pre class="plaintext">Allows the specification of an expression that will be evaluated before
the `defn` form (presumably for side-effects). Provides:
  * &amp;ns - The namespace in which this fn is being interned
  * &amp;name - The symbol used to name this defn.
  * &amp;meta - The metadata attached to the fn name.
  * &amp;env-keys - The keys of the &amp;env map known to the `defn` macro.
Example:
(prefix-form fn-form
             `(println (format "Compiling %s/%s now."
                               (ns-name &amp;ns)
                               &amp;name)))</pre></div></div></div></body></html>