<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Morphe API Docs</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Morphe</span> </span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="morphe.core.html"><div class="inner"><span>morphe.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="morphe.core.html#var-*warn-on-noop*"><div class="inner"><span>*warn-on-noop*</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-alter-bodies"><div class="inner"><span>alter-bodies</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-alter-bodies*"><div class="inner"><span>alter-bodies*</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-alter-form"><div class="inner"><span>alter-form</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-apply-aspect"><div class="inner"><span>apply-aspect</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-defn"><div class="inner"><span>defn</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-fn-form-.3Edefn"><div class="inner"><span>fn-form-&gt;defn</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-parse-defn"><div class="inner"><span>parse-defn</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-prefix-bodies"><div class="inner"><span>prefix-bodies</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-prefix-bodies*"><div class="inner"><span>prefix-bodies*</span></div></a></li><li class="depth-1"><a href="morphe.core.html#var-prefix-form"><div class="inner"><span>prefix-form</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">morphe.core</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-*warn-on-noop*"><h3>*warn-on-noop*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-alter-bodies"><h3>alter-bodies</h3><h4 class="type">macro</h4><div class="usage"><code>(alter-bodies fn-form expression)</code></div><div class="doc"><div class="markdown"><p>Allows specification of code that should wrap each body of the <code>defn</code> form. Provides:  * &amp;params - The paramaters corresponding to this arity.  * &amp;body - The collection of expressions in the body of this arity.  * &amp;ns - The namespace in which this fn is being interned  * &amp;name - The symbol used to name this defn.  * &amp;meta - The metadata attached to the fn name.  * &amp;env-keys - The keys of the &amp;env map known to the <code>defn</code> macro. NOTA BENE: &amp;body is an <em>ordered collection</em> of valid expressions. Example: (alter-bodies fn-form  `(binding [<em>scope</em> ~[(ns-name &amp;ns) &amp;name &amp;params]]  ~@&amp;body))</p></div></div></div><div class="public anchor" id="var-alter-bodies*"><h3>alter-bodies*</h3><div class="usage"><code>(alter-bodies* fn-form f)</code></div><div class="doc"><div class="markdown"><p>Takes a fn-form and a function of args [params body] and replaces each body in the fn-form with the result of applying the function to the params and the body! body should be assumed to be a collection of valid expressions.</p></div></div></div><div class="public anchor" id="var-alter-form"><h3>alter-form</h3><h4 class="type">macro</h4><div class="usage"><code>(alter-form fn-form expression)</code></div><div class="doc"><div class="markdown"><p>Allows specification of code that would wrap the entire <code>defn</code> form. Useful mainly for providing a lexical scope (e.g., evaluating the <code>defn</code> within the body of a <code>let</code>). Provides:  * &amp;ns - The namespace in which this fn is being interned  * &amp;name - The symbol used to name this defn.  * &amp;meta - The metadata attached to the fn name.  * &amp;env-keys - The keys of the &amp;env map known to the <code>defn</code> macro.  * &amp;form - A placeholder for the actual form – not the form itself. NOTA BENE: &amp;form should always be assumed to represent a <em>single</em> expression. Example: (alter-form fn-form `(binding [*my-var* 3 ~&amp;form)))</p></div></div></div><div class="public anchor" id="var-apply-aspect"><h3>apply-aspect</h3><div class="usage"><code>(apply-aspect fn-form aspect)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-defn"><h3>defn</h3><h4 class="type">macro</h4><div class="usage"><code>(defn name doc-string? attr-map? [params*] prepost-map? body)</code><code>(defn name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?)</code></div><div class="doc"><div class="markdown"><p>Should behave exactly like clojure.core/defn, except: You can tag the fn name with aspects: <code>^{:morphe.core/aspects [aspects ...]}</code> The aspects must be functions of one argument that know how to manipulate a morphe.core/FnForm record.</p>
<p>In implementation, it basically uses the guts of clojure.core/defn to parse the definition, representing the parsed form with a FnForm record, which then gets operated on by composable modification fns (aspects).</p>
<p>The FnForm record has the following fields:  :env - the <code>&amp;env</code> var inside the <code>defn</code> call.  :wrapper - A single expression not equal to, but representing any code that  should wrap the <code>defn</code> call.  :namespace - The namespace in which the fn is being interned.  :fn-name - The symbolic name of the function being defined.  :metadata - The metadata that was attached to the fn-name.  :arglists - A sequence of arglists, one for each arity.  :bodies - A sequence of arity bodies, where each body is a collection of expressions.</p></div></div></div><div class="public anchor" id="var-fn-form-.3Edefn"><h3>fn-form-&gt;defn</h3><div class="usage"><code>(fn-form-&gt;defn fn-form)</code></div><div class="doc"><div class="markdown"><p>Finally turns the FnForm record back into a complete code body.</p></div></div></div><div class="public anchor" id="var-parse-defn"><h3>parse-defn</h3><div class="usage"><code>(parse-defn name &amp; fdecl)</code></div><div class="doc"><div class="markdown"><p>This duplicates Clojure.core’s <code>defn</code>, but instead of constructing the function definition, this returns a FnForm record containing the result of parsing the defn.</p></div></div></div><div class="public anchor" id="var-prefix-bodies"><h3>prefix-bodies</h3><h4 class="type">macro</h4><div class="usage"><code>(prefix-bodies fn-form expression)</code></div><div class="doc"><div class="markdown"><p>Allows the specification of an expression that will be added to the beginning of each fn arity (presumably for side-effects). Provides:  * &amp;params - The paramaters corresponding to this arity.  * &amp;ns - The namespace in which this fn is being interned  * &amp;name - The symbol used to name this defn.  * &amp;meta - The metadata attached to the fn name.  * &amp;env-keys - The keys of the &amp;env map known to the <code>defn</code> macro. Example: (prefix-bodies fn-form `(assert (even? 4) “Math still works.”))</p></div></div></div><div class="public anchor" id="var-prefix-bodies*"><h3>prefix-bodies*</h3><div class="usage"><code>(prefix-bodies* fn-form f)</code></div><div class="doc"><div class="markdown"><p>Takes a fn-form and a function of args [params] and prefixes each body in the fn-form with the result of applying the function to the params!</p></div></div></div><div class="public anchor" id="var-prefix-form"><h3>prefix-form</h3><h4 class="type">macro</h4><div class="usage"><code>(prefix-form fn-form expression)</code></div><div class="doc"><div class="markdown"><p>Allows the specification of an expression that will be evaluated before the <code>defn</code> form (presumably for side-effects). Provides:  * &amp;ns - The namespace in which this fn is being interned  * &amp;name - The symbol used to name this defn.  * &amp;meta - The metadata attached to the fn name.  * &amp;env-keys - The keys of the &amp;env map known to the <code>defn</code> macro. Example: (prefix-form fn-form  `(println (format “Compiling %s/%s now.”  (ns-name &amp;ns)  &amp;name)))</p></div></div></div></div></body></html>